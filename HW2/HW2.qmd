---
title: "STATS 506 HW2"
author: "Minxuan Chen"
date: last-modified
format:
  pdf:
    toc: true
    number-sections: true
    colorlinks: true
  html:
    toc: true
    css: styles.css
    fig-align: "center"
    fig-width: 8
    fig-height: 6
    embed-resources: true
    format-links: false
    execute:
      warning: true
      freeze: auto
code-fold: show
code-overflow: scroll
code-line-numbers: true
---
Github repo: <https://github.com/PKUniiiiice/STATS_506>

## Problem 1 Dice Game
### a
```{r p1a}
# For simplicity, for all functions below, we assume the input `x`
# is always legal, i.e. always an integer.

#' Function to for a dice game -- loop version
#'
#' @param x the number of dice to roll
#' @return total winnings or loses
play_dice_loop <- function(x){
  #initial money
  money <- 0
  for (i in 1:x){
    # out of rolling
    out <- sample.int(6,1)
    money <- money - 2 + (-(out%%2)+1)*out
  }
  return (money)
}

#' Function to for a dice game -- built-in R vectorized version
#'
#' @param x the number of dice to roll
#' @return total winnings or loses
play_dice_vec <- function(x){
  #initial money
  money <- rep(-2, x)
  out <- sample.int(6, size=x, replace=TRUE)
  money <- money + (-(out%%2)+1)*out
  return(sum(money))
}

#' Function to for a dice game -- built-in R vectorized version
#'
#' @param x the number of dice to roll
#' @return total winnings or loses
play_dice_vec <- function(x){
  #initial money
  money <- rep(-2, x)
  out <- sample.int(6, size=x, replace=TRUE)
  money <- money + (-(out%%2)+1)*out
  return(sum(money))
}

#' Function to for a dice game -- table version
#'
#' @param x the number of dice to roll
#' @return total winnings or loses
play_dice_table <- function(x){
  out <- factor(sample.int(6, size=x, replace=TRUE), levels=1:6)
  #make a table from out
  out.tab <- table(out)
  money <- -2*x + sum(as.numeric(out.tab[c(2,4,6)])*c(2,4,6))
  return(money)
}

#' Function to for a dice game -- apply version
#' 
#' @param x the number of dice to roll
#' @return total winnings or loses
play_dice_apply <- function(x){
  
  #We def another function to calculate money
  money_cal <- function(x){
    return ( -2 + (-(x%%2)+1) * x )  
  }
  out <- sample.int(6, size=x, replace=TRUE)
  money <- sum(sapply(out, money_cal))
  return (money)
}

```

### b
```{r p1b}
for (x in c(3,3000,100000)){
  cat("Number of dice to roll: ", x, "\n")
  print(play_dice_loop(x))
  print(play_dice_vec(x))
  print(play_dice_table(x))
  print(play_dice_apply(x))
}
```

### c
We use `set.seed()`before each call to control the randomization.
```{r p1c}
for (i in list(c(3,2873), c(3000,18218))){
  cat("Number of dice to roll: ", i[1], "\n")
  set.seed(i[2])
  print(play_dice_loop(i[1]))
  
  set.seed(i[2])
  print(play_dice_vec(i[1]))
  
  set.seed(i[2])
  print(play_dice_table(i[1]))
  
  set.seed(i[2])
  print(play_dice_apply(i[1]))
}
```

The four versions can give the same result.

### d
```{r p1d}
library(microbenchmark)
ress <- list()
for (x in c(10, 100, 1000, 10000)){
  cat(log10(x)," Number of dice to roll: ", x, "\n")
  result <- microbenchmark(
    loop = play_dice_loop(x),
    vectorized = play_dice_vec(x),
    table = play_dice_table(x),
    apply = play_dice_apply(x)
  )
  ress <- append(ress, list(result))
}
print(ress)
```

It's obvious that the vectorized version is the fastest, while the pure for-loop version is the slowest. This is a natural result of the fact that built-in vectorized functions are executed in compiled C or Fortran code, as opposed to much more R codes that a for-loop uses.

As for the 'apply' version, it involves loop-hiding. We use `sapply`, which calls `lapply`. The later drop down to C for its loops, however, at each step in the C loop, they evaluate the R function (i.e. `money_cal`) passed in. So it is slower than vectorization but not as slow as a pure for-loop.

The table version is slightly slower than vectorization. The main reason is the conversion of the rolling result to a factor and the subsequent counting of its frequency.


When we compare the performance between a small input size (100) and a large input size (10000), a significant increase in time cost becomes evident for the for-loop version, approximately 100 times slower for the larger input. However, the other three versions do not exhibit such a substantial increase.

Upon closer examination of the time cost as it changes from 10 to 10000, we observe distinct patterns. The for-loop and `apply` versions show a linear increase with a slope approx 1. In contrast, the table and vectorization versions display a relatively flatter curve initially.

### e
We care about the total amount of money after $n$ dice games, denoting it by $X_n$. Let $M_i$ represent the single income we obtain after the i-th dice game . $M_i$s are i.i.d. Then
$$
X_n = \sum_{i=1}^nM_i
$$
To judge whether the game is fair, we calculate
$$
EX_n = E\left(\sum_{i=1}^nM_i\right) = nEM_1
$$
In theory
$$
EM_1 = \frac{1}{6}(-2\times6+2+4+6)=0 \to EX_n=0
$$
That is, no matter how many games we play, the expected income is 0, so this is a fair game.

We can  show this conclusion using Monte Carlo simulation. Our goal is to estimate $EM_1$. Due to i.i.d of $M_i$s, we can directly use the output of `play_dice(n)`. For example, if the sample size is 10000000,
```{r p1e}
play_dice_vec(10000000)/10000000
```
This value is close to zero, so we claim that $\widehat{EM_i}=0$, then $\widehat{EX_n}=0$.

## Problem 2 Linear Regression
### a
```{r p2a}
cars <- read.csv("./cars.csv")

newname <- colnames(cars)
for (i in 1:dim(cars)[2]){
  tmp <- unlist(strsplit(newname[i], "[.]"))
  if (i<4){
    newname[i] = tmp[2]
  }
  else if (i<12){
    newname[i] = paste(tmp[3:length(tmp)],collapse='.')
  }
  else if (i<17){
    newname[i] = paste(tmp[2:length(tmp)],collapse='.')
  }
  else{
    newname[i] = paste(tmp[5:length(tmp)],collapse='.')
  }
}

colnames(cars) <- newname
```

### b
```{r p2b}
cars <- cars[cars$Fuel.Type=="Gasoline", ]

```

### c
We need to introduce these variables into the model for controlling.
```{r p2c}
# we need to convert year to factor at first
cars$f.years <- as.factor(cars$Year)

m.mpg <- lm(Highway.mpg ~ Horsepower + Torque + Height + 
                          Length + Width + f.years, data=cars,
            x=TRUE)

summary(m.mpg)
```

As we use a nominal factor to represent the categorical variable `Year`, the regression result includes three additional variables labeled as `f.years20xx`. These variables represent the differences relative to the reference year, which is `Year=2009`.

From the regression results, $\beta_{\text{Horsepower}}\doteq 0.0164$ indicates that on average MPG on the highway increases by 0.0164 with a unit increase in horsepower, when all other variables in this model are held constant (i.e. controlling all other variables).

(Note: the term "controlling all other variables"      
For those other than `Year`, it means that they are held constant when making comparisons. As for `Year`, which has three terms in the model, it implies we only compare cars released in the same year, i.e., 2009 to 2009, 2010 to 2010, and so on.)

### d
```{r p2d}
m.inter.mpg <- lm(Highway.mpg ~ Horsepower + Torque + 
                                Horsepower:Torque + Height + 
                                Length + Width + f.years, data=cars, x=TRUE)

summary(m.inter.mpg)
```

Note that the interaction term has a positive regression coefficient, so we expect that the slope of `MPG-Horsepower` line will increase with increase in Torque.

We choose the 25\%, 50\% and 75\% quantile value of Torque as three typical values to draw the interaction plot. Moreover, we fix the `Year` variables to the same value in one plot and draw 4 plots in total to reflect 4 levels of `Year`. As for other variables (all three dimensions), we use the default value given by function `interact_plot()`.

```{r p2d 2}
#| fig-width: 10
#| fig-height: 8
library(interactions)
t1 <- interact_plot(m.inter.mpg, pred=Horsepower, modx=Torque,
                    modx.values=as.numeric(quantile(cars$Torque)[2:4]),
                    at=list(f.years=factor(2009,
                              levels=c("2009", "2010", "2011", "2012")))) + 
                    ggplot2::labs(title = "Year=2009")

t2 <- interact_plot(m.inter.mpg, pred=Horsepower, modx=Torque,
                    modx.values=as.numeric(quantile(cars$Torque)[2:4]),
                    at=list(f.years=factor(2010,
                              levels=c("2009", "2010", "2011", "2012")))) +
                    ggplot2::labs(title = "Year=2010")

t3 <- interact_plot(m.inter.mpg, pred=Horsepower, modx=Torque,
                    modx.values=as.numeric(quantile(cars$Torque)[2:4]),
                    at=list(f.years=factor(2011,
                              levels=c("2009", "2010", "2011", "2012")))) +
                    ggplot2::labs(title = "Year=2011")

t4 <- interact_plot(m.inter.mpg, pred=Horsepower, modx=Torque,
                    modx.values=as.numeric(quantile(cars$Torque)[2:4]),
                    at=list(f.years=factor(2012,
                              levels=c("2009", "2010", "2011", "2012")))) +
                    ggplot2::labs(title = "Year=2012")

library(gridExtra)

grid.arrange(t1, t2, t3, t4, ncol = 2)

```

Note that the difference among years is just in intercept i.e. (translation of lines), which is because `Year` and `Horsepower` have no interaction.

### e
We try to reproduce the results in part c and d.
```{r p2e}
cal.beta <- function(y, design){
  design <- as.matrix(design)
  xtx.inv <- solve(crossprod(design))
  return (xtx.inv %*% t(design) %*% y)
}

#part c design
design.pc <- cars[c("Horsepower", "Torque", "Height", "Length", "Width")]
design.pc <- cbind(rep(1, dim(cars)[1]),
                   design.pc,
                   model.matrix(~cars$f.years)[,2:4])


#part d design
inter <- cars$Horsepower * cars$Torque
design.pd <- cbind(design.pc, inter)

y.cd <- cars$Highway.mpg

#beta of part c
cal.beta(y.cd, design.pc)

#beta of part d
cal.beta(y.cd, design.pd)
```

We got the same result as `lm` did prior.

## Problem 3





